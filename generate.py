import subprocess
import sys
import re
from rich.progress import SpinnerColumn, Progress, TextColumn
from fpdf import FPDF

class Findings:
    def __init__(self, category, description, reference, code):
        self.category = category
        self.description = description
        self.reference = reference
        self.code = code

class PDF(FPDF):
    def __init__(self):
        super().__init__()
        # Set proper page margins
        self.set_margins(20, 20, 20)  # Left, Top, Right margins
        self.set_auto_page_break(auto=True, margin=25)  # Bottom margin
    
    def header(self):
        # Set background color for header
        self.set_fill_color(240, 240, 240)
        self.rect(0, 0, self.w, 25, 'F')
        
        # Company/Project title
        self.set_font('Arial', 'B', size=12)
        self.set_text_color(50, 50, 50)
        self.cell(0, 10, 'Static Application Security Testing Report', 0, 0, 'C')
        
        # Subtitle
        self.set_font('Arial', '', size=8)
        self.set_text_color(100, 100, 100)
        self.cell(0, 10, 'Generated by Semgrep CLI', 0, 0, 'C')
        
        # Line break
        self.ln(20)

    def footer(self):
        # Position at 1.5 cm from bottom
        self.set_y(-15)
        # Set footer background
        self.set_fill_color(240, 240, 240)
        self.rect(0, self.h-15, self.w, 15, 'F')
        
        # Page number and generation info
        self.set_font('Arial', '', size=8)
        self.set_text_color(100, 100, 100)
        
        # Left side - Generation timestamp
        self.cell(0, 10, f'Generated: {self.get_generation_time()}', 0, 0, 'L')
        
        # Right side - Page number
        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'R')

    def get_generation_time(self):
        """Get current timestamp for footer"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Clean latin-1
    def clean_text(self, text):
        return text.encode("latin-1", "ignore").decode("latin-1")

    # Handle long text by truncating if necessary
    def truncate_text(self, text, max_length=150):
        if len(text) <= max_length:
            return text
        return text[:max_length-3] + "..."

    # Handle long text by truncating based on available height
    def truncate_text_by_height(self, text, max_width, max_height, line_height=6):  # Changed default from 10 to 6
        # Calculate how many lines we can fit
        max_lines = int(max_height / line_height)
        # Use consistent character width calculation
        chars_per_line = int(max_width / 1.7)  # Updated from 1.6 to 1.7
        
        # If text fits in one line, return as is
        if len(text) <= chars_per_line:
            return text
        
        # For text with hyphens, be extra careful about line breaks
        if '-' in text:
            # Try to keep hyphenated terms together
            words = text.split()
            lines = []
            current_line = ""
            
            for word in words:
                # Check if adding this word would exceed the line width
                test_line = current_line + " " + word if current_line else word
                
                if len(test_line) <= chars_per_line:
                    # Word fits on current line
                    current_line = test_line
                else:
                    # Word doesn't fit, but check if it contains hyphens
                    if '-' in word and len(word) > chars_per_line:
                        # This word has hyphens and is too long - keep it together
                        if current_line:
                            lines.append(current_line)
                        lines.append(word)
                        current_line = ""
                    else:
                        # Normal word, start new line
                        if current_line:
                            lines.append(current_line)
                        current_line = word
            
            # Add the last line if there's content
            if current_line:
                lines.append(current_line)
            
            # Limit to max_lines and join
            if len(lines) <= max_lines:
                return '\n'.join(lines)
            else:
                # If we have more lines than can fit, truncate at word boundaries
                truncated_lines = lines[:max_lines]
                return '\n'.join(truncated_lines)
        
        # Original logic for text without hyphens
        # Split text into words and build lines intelligently
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            # Check if adding this word would exceed the line width
            test_line = current_line + " " + word if current_line else word
            
            if len(test_line) <= chars_per_line:
                # Word fits on current line
                current_line = test_line
            else:
                # Word doesn't fit, start new line
                if current_line:
                    lines.append(current_line)
                    current_line = word
                else:
                    # Single word is too long, split it intelligently
                    if len(word) > chars_per_line:
                        # Try to break at hyphens or underscores first
                        if '-' in word:
                            parts = word.split('-')
                            for i, part in enumerate(parts):
                                if i > 0:
                                    part = '-' + part
                                if len(part) <= chars_per_line:
                                    lines.append(part)
                                else:
                                    # Break long part into chunks
                                    for j in range(0, len(part), chars_per_line):
                                        chunk = part[j:j + chars_per_line]
                                        lines.append(chunk)
                        elif '_' in word:
                            parts = word.split('_')
                            for i, part in enumerate(parts):
                                if i > 0:
                                    part = '_' + part
                                if len(word) <= chars_per_line:
                                    lines.append(word)
                                else:
                                    # Break long word into chunks
                                    for i in range(0, len(word), chars_per_line):
                                        chunk = word[i:i + chars_per_line]
                                        lines.append(chunk)
                        else:
                            # Break long word into chunks
                            for i in range(0, len(word), chars_per_line):
                                chunk = word[i:i + chars_per_line]
                                lines.append(chunk)
                    else:
                        lines.append(word)
                    current_line = ""
        
        # Add the last line if there's content
        if current_line:
            lines.append(current_line)
        
        # Limit to max_lines and join
        if len(lines) <= max_lines:
            return '\n'.join(lines)
        else:
            # If we have more lines than can fit, truncate at word boundaries
            truncated_lines = lines[:max_lines]
            return '\n'.join(truncated_lines)

    # Specialized method for second column to maximize space utilization
    def optimize_second_column_layout(self, text, max_width, line_height=6):
        """Optimize layout specifically for the second column to minimize wasted space"""
        # Use even more aggressive character width calculation for data column
        chars_per_line = int(max_width / 1.7)  # Updated from 1.6 to 1.7
        
        if len(text) <= chars_per_line:
            return text
        
        # Split text into words and build highly optimized lines
        words = text.split()
        lines = []
        current_line = ""
        
        for i, word in enumerate(words):
            # Check if adding this word would exceed the line width
            test_line = current_line + " " + word if current_line else word
            
            if len(test_line) <= chars_per_line:
                # Word fits on current line
                current_line = test_line
            else:
                # Word doesn't fit, optimize current line before breaking
                if current_line:
                    # Calculate wasted space
                    wasted_space = chars_per_line - len(current_line)
                    
                    # If wasted space is more than 15% (more aggressive than 20%), try to fit more
                    if wasted_space > chars_per_line * 0.15:
                        # Look ahead more aggressively to find better line combinations
                        remaining_words = words[i:]
                        best_line = current_line
                        best_utilization = len(current_line) / chars_per_line
                        
                        # Try different combinations of remaining words
                        temp_line = current_line
                        for j, next_word in enumerate(remaining_words):
                            test_temp = temp_line + " " + next_word
                            if len(test_temp) <= chars_per_line:
                                temp_line = test_temp
                                utilization = len(temp_line) / chars_per_line
                                
                                # Keep the line with best space utilization
                                if utilization > best_utilization:
                                    best_line = temp_line
                                    best_utilization = utilization
                            else:
                                break
                        
                        # Use the best line we found
                        if best_utilization > len(current_line) / chars_per_line:
                            current_line = best_line
                            # Skip the words we just added
                            i += len(best_line.split()) - len(current_line.split()) - 1
                    
                    # Add the optimized line
                    lines.append(current_line)
                    current_line = word
                else:
                    # Start new line
                    current_line = word
        
        # Add the last line if there's content
        if current_line:
            lines.append(current_line)
        
        return '\n'.join(lines)

    # Create a smart summary for extremely long descriptions
    def create_smart_summary(self, text, max_lines=12, chars_per_line=60):  # Increased max_lines from 8 to 12
        """Create a smart summary for very long descriptions"""
        if len(text) <= chars_per_line * 2:
            return text  # Short enough, return as is
        
        # Split into sentences for better summary
        sentences = text.split('. ')
        if len(sentences) <= 2:
            # If only 1-2 sentences, just truncate at word boundary
            words = text.split()
            summary = ""
            for word in words:
                if len(summary + " " + word) <= chars_per_line * max_lines:
                    summary += " " + word if summary else word
                else:
                    break
            return summary + "..." if len(summary) < len(text) else summary
        
        # Take first few sentences that fit within the limit
        summary = ""
        for sentence in sentences:
            if len(summary + sentence + ". ") <= chars_per_line * max_lines:
                summary += sentence + ". " if summary else sentence + ". "
            else:
                break
        
        # Clean up and add ellipsis if truncated
        summary = summary.strip()
        if len(summary) < len(text):
            summary += " [Full description available in scan output]"
        
        return summary

    # Optimize text layout to better utilize available space
    def optimize_text_layout(self, text, max_width, line_height=6):
        """Optimize text layout to minimize unnecessary line breaks and reduce wasted space"""
        # Use consistent character width calculation
        chars_per_line = int(max_width / 1.7)  # Updated from 1.6 to 1.7
        
        if len(text) <= chars_per_line:
            return text
        
        # Split text into words and build optimized lines
        words = text.split()
        lines = []
        current_line = ""
        
        for i, word in enumerate(words):
            # Check if adding this word would exceed the line width
            test_line = current_line + " " + word if current_line else word
            
            if len(test_line) <= chars_per_line:
                # Word fits on current line
                current_line = test_line
            else:
                # Word doesn't fit, but check if we can optimize the current line
                if current_line:
                    # Check if current line has significant wasted space
                    wasted_space = chars_per_line - len(current_line)
                    
                    # If wasted space is more than 20% of line width, try to fit more words
                    if wasted_space > chars_per_line * 0.2:
                        # Look ahead to see if we can fit more words
                        remaining_words = words[i:]
                        temp_line = current_line
                        
                        for next_word in remaining_words:
                            test_temp = temp_line + " " + next_word
                            if len(test_temp) <= chars_per_line:
                                temp_line = test_temp
                            else:
                                break
                        
                        # If we found a better line, use it
                        if len(temp_line) > len(current_line):
                            current_line = temp_line
                            # Skip the words we just added
                            i += len(temp_line.split()) - len(current_line.split()) - 1
                    
                    # Add the optimized line
                    lines.append(current_line)
                    current_line = word
                else:
                    # Start new line
                    current_line = word
        
        # Add the last line if there's content
        if current_line:
            lines.append(current_line)
        
        return '\n'.join(lines)

    # Specialized method for category text to prevent unnecessary line breaks
    def optimize_category_text(self, text, max_width, line_height=6):
        """Optimize category text to prevent line breaks for hyphenated terms"""
        # For categories, we want to keep hyphenated terms together
        if '-' not in text:
            # No hyphens, use normal optimization
            return self.optimize_text_layout(text, max_width, line_height)
        
        # Check if the entire category fits on one line
        chars_per_line = int(max_width / 1.7)
        if len(text) <= chars_per_line:
            return text
        
        # If it doesn't fit, be very conservative about breaking
        # Only break if the text is significantly longer than the line width
        if len(text) > chars_per_line * 1.5:  # Only break if 50% longer than line width
            # Try to break at dots (.) but be very careful
            if '.' in text:
                parts = text.split('.')
                if len(parts) == 2:
                    # Only two parts, try to keep them together if possible
                    if len(parts[0]) + len(parts[1]) + 1 <= chars_per_line * 1.3:
                        return text  # Keep together
                
                # Multiple parts, try minimal breaking
                lines = []
                current_line = ""
                
                for part in parts:
                    test_line = current_line + "." + part if current_line else part
                    
                    if len(test_line) <= chars_per_line:
                        current_line = test_line
                    else:
                        if current_line:
                            lines.append(current_line)
                        current_line = part
                
                if current_line:
                    lines.append(current_line)
                
                # If we only have one line or the result is not significantly better, return original
                if len(lines) <= 1 or len(lines) == 2 and len(text) <= chars_per_line * 1.3:
                    return text
                
                return '\n'.join(lines)
        
        # If we get here, the text is not long enough to warrant breaking
        # Return the original text to preserve structure
        return text

    # Specialized method for Affected Lines to handle code snippets properly
    def optimize_affected_lines(self, text, max_width, line_height=6):
        """Optimize Affected Lines to handle code snippets and prevent overflow"""
        # For code snippets, we need to be more careful about line breaks
        chars_per_line = int(max_width / 1.7)
        
        if '\n' in text:
            # Multi-line code snippet
            lines = text.split('\n')
            optimized_lines = []
            
            for line in lines:
                if len(line) <= chars_per_line:
                    # Line fits, keep as is
                    optimized_lines.append(line)
                else:
                    # Line is too long, need to break it
                    if len(line) > chars_per_line * 2:
                        # Very long line, truncate with ellipsis
                        optimized_lines.append(line[:chars_per_line] + "...")
                    else:
                        # Moderately long line, try to break at spaces
                        words = line.split()
                        current_line = ""
                        
                        for word in words:
                            test_line = current_line + " " + word if current_line else word
                            if len(test_line) <= chars_per_line:
                                current_line = test_line
                            else:
                                if current_line:
                                    optimized_lines.append(current_line)
                                current_line = word
                        
                        if current_line:
                            optimized_lines.append(current_line)
            
            # Limit to reasonable number of lines to prevent cell overflow
            if len(optimized_lines) > 4:
                return '\n'.join(optimized_lines[:4]) + "\n[Additional lines available in scan output]"
            else:
                return '\n'.join(optimized_lines)
        else:
            # Single line, use normal optimization
            if len(text) <= chars_per_line:
                return text
            else:
                # Long single line, truncate appropriately
                return text[:chars_per_line] + "..." if len(text) > chars_per_line else text

    # Calculate the height needed for text in a given width
    def calculate_text_height(self, text, width, line_height=6):  # Changed default from 10 to 6
        # Calculate how many lines the text will actually take with word wrapping
        # Use consistent character width calculation
        chars_per_line = int(width / 1.7)  # Updated from 1.6 to 1.7
        
        if len(text) <= chars_per_line:
            return line_height
        
        # Split text into words and calculate actual lines needed
        words = text.split()
        lines = 1  # Start with 1 line
        current_line_length = 0
        
        for word in words:
            # Add space if not first word
            word_with_space = " " + word if current_line_length > 0 else word
            
            if current_line_length + len(word_with_space) <= chars_per_line:
                # Word fits on current line
                current_line_length += len(word_with_space)
            else:
                # Word doesn't fit, start new line
                lines += 1
                current_line_length = len(word)
        
        # Calculate total height needed
        total_height = lines * line_height
        
        # Ensure minimum height
        return max(total_height, line_height)

    # Check if there's enough space on the current page for a table row
    def check_page_break(self, required_height):
        # Get current Y position and page height
        current_y = self.get_y()
        page_height = self.h
        margin = 25  # Bottom margin - increased for better spacing
        
        # Check if adding the required height would exceed the page
        if current_y + required_height > page_height - margin:
            return True  # Need page break
        return False  # Enough space

    # Check if there's enough space for a section header
    def check_header_space(self, header_height=15):
        return self.check_page_break(header_height)

    # Ensure proper table positioning within margins
    def ensure_table_position(self):
        # Reset to proper left margin for tables
        self.set_x(20)
        # Ensure we have enough space from top
        if self.get_y() < 40:  # Account for header
            self.set_y(40)

    # Get available width for content (respecting margins)
    def get_available_width(self):
        return self.w - 40  # Page width minus left and right margins

    # Create a table cell with proper vertical alignment
    def create_aligned_cell(self, width, height, text, border=1, align='C', fill=False):
        # Calculate vertical center position for the text
        text_height = 10  # Height of single line text
        y_offset = (height - text_height) / 2
        
        # Store current position
        current_x = self.get_x()
        current_y = self.get_y()
        
        # Draw the cell border
        self.cell(width, height, '', border, ln=0, fill=fill)
        
        # Position text in the center of the cell
        self.set_xy(current_x, current_y + y_offset)
        self.cell(width, text_height, text, 0, align=align, ln=0)
        
        # Don't change position - let the calling method control it
        # This ensures table continuity

    # Create a multi_cell with exact height control
    def create_exact_height_cell(self, width, height, text, border=1, fill=False):
        # Store current position
        current_x = self.get_x()
        current_y = self.get_y()
        
        # Draw the cell border with exact height
        self.cell(width, height, '', border, ln=0, fill=fill)
        
        # Calculate line height to fit text within the exact height
        line_height = 6  # Reduced line height for tighter spacing
        max_lines = int(height / line_height)
        
        # Use multi_cell but limit to the exact height
        self.set_xy(current_x, current_y)
        self.multi_cell(width, line_height, text, 0, fill=fill)
        
        # Don't change position - let the calling method control it
        # This ensures table continuity

    # Old code, to write the findings directly not in a table format
    # def write_findings(self, findings,type):
    #     if findings:
    #         self.multi_cell(200, 10, txt= type + " Severity Level")
    #         for finding in findings:
    #             self.multi_cell(200, 10, txt="Category: " + self.clean_text(str(finding.category)))
    #             self.multi_cell(200, 10, txt="Description: " + self.clean_text(str(finding.description))) 
    #             self.multi_cell(200, 10, txt="Reference: " + self.clean_text(str(finding.reference)))
    #             self.multi_cell(200, 10, txt="Affected Lines: " + self.clean_text(str(finding.code)))
    #             self.ln(1)

    # Function to create and write table
    def create_table(self,text, data, is_severity=False):
        self.set_font('Arial', '', 10)
        self.set_fill_color(255, 255, 255)

        if is_severity:
            if data == "High":
                self.set_fill_color(255, 204, 204)
            elif data == "Medium":
                self.set_fill_color(255, 255, 204)
            elif data == "Low":
                self.set_fill_color(204, 255, 204)
        
        # Use full text instead of aggressive truncation
        display_data = str(data)
        
        # For descriptions, check if they're extremely long and create smart summaries
        if text == "Category" and '-' in str(data):
            # For categories with hyphens, treat them as single units to prevent line breaks
            display_data = str(data)
        elif text == "Description" and len(display_data) > 500:  # Very long descriptions
            display_data = self.create_smart_summary(display_data)
        elif text == "Reference" and len(display_data) > 300:  # Long references
            display_data = self.create_smart_summary(display_data, max_lines=4, chars_per_line=60)
        elif text == "Affected Lines" and len(display_data) > 200:  # Long code snippets
            # For code, try to show the most relevant part
            if '\n' in display_data:
                lines = display_data.split('\n')
                if len(lines) > 3:
                    display_data = '\n'.join(lines[:3]) + "\n[Additional lines available in scan output]"
            else:
                display_data = display_data[:200] + "..." if len(display_data) > 200 else display_data
        
        # Calculate the actual height needed for the data text
        line_height = 6  # Reduced from 10 to 6 for tighter line spacing
        available_width = self.get_available_width()
        data_width = available_width - int(available_width * 0.2)  # Calculate data width
        data_height = self.calculate_text_height(display_data, data_width, line_height)
        
        # Apply intelligent text wrapping that respects word boundaries
        display_data = self.truncate_text_by_height(str(display_data), data_width, data_height, line_height)
        
        # Use specialized optimization based on field type
        if text == "Category":
            # Use category-specific optimization to prevent line breaks for hyphenated terms
            display_data = self.optimize_category_text(display_data, data_width, line_height)
        elif text == "Affected Lines":
            # Use Affected Lines specific optimization to handle code snippets
            display_data = self.optimize_affected_lines(display_data, data_width, line_height)
        else:
            # Use specialized optimization for the second column to minimize wasted space
            display_data = self.optimize_second_column_layout(display_data, data_width, line_height)
        
        # Check if we need a page break to keep the table row together
        if self.check_page_break(data_height):
            self.add_page()
        
        # Ensure we're within page margins
        current_x = self.get_x()
        if current_x < 20:  # Left margin
            self.set_x(20)
        elif current_x > self.w - 200:  # Right margin (table width is 200)
            self.set_x(20)  # Reset to left margin
        
        # Calculate column widths based on available space
        available_width = self.get_available_width()
        label_width = int(available_width * 0.2)  # 20% for label
        data_width = available_width - label_width  # Remaining for data
        
        # Store current x position
        x_pos = self.get_x()
        y_pos = self.get_y()
        
        # First column (label) - use same height as data column and center text vertically
        self.create_aligned_cell(label_width, data_height, text, border=1, align='C', fill=False)
        
        # Second column (data) - use exact height control to match first column
        self.set_xy(x_pos + label_width, y_pos)
        self.create_exact_height_cell(data_width, data_height, display_data, border=1, fill=True)
        
        # Position for next row - both cells now have exactly the same height
        # Don't use ln() as it breaks table continuity
        self.set_xy(20, y_pos + data_height)  # Reset to left margin, move down by cell height

    # The function to iterate through the available findings and write to data
    def write_to_table(self, findings, type):
        col_width = 50
        if findings:
            for i, finding in enumerate(findings):
                # Ensure proper table positioning
                self.ensure_table_position()
                
                # Calculate total height needed for this finding
                total_height = 0
                available_width = self.get_available_width()
                data_width = available_width - int(available_width * 0.2)
                total_height += self.calculate_text_height(str(finding.category), data_width, 6)
                total_height += self.calculate_text_height(str(finding.description), data_width, 6)
                total_height += 6  # Severity level row (reduced height)
                total_height += self.calculate_text_height(str(finding.reference), data_width, 6)
                
                # Special handling for Affected Lines to account for multi-line code
                affected_lines_text = str(finding.code)
                if '\n' in affected_lines_text:
                    # Multi-line code snippet
                    lines = affected_lines_text.split('\n')
                    # Limit to 4 lines maximum to prevent overflow
                    limited_lines = lines[:4]
                    affected_lines_text = '\n'.join(limited_lines)
                    if len(lines) > 4:
                        affected_lines_text += "\n[Additional lines available in scan output]"
                
                total_height += self.calculate_text_height(affected_lines_text, data_width, 6)
                total_height += 15  # Add spacing between rows
                
                # Check if we need a page break to keep the entire finding together
                if self.check_page_break(total_height):
                    self.add_page()
                    self.ensure_table_position()  # Reset position on new page
                
                self.create_table("Category",self.clean_text(str(finding.category)))
                self.create_table("Description",self.clean_text(str(finding.description)))
                self.create_table("Severity Level", type, is_severity=True)
                self.create_table("Reference",self.clean_text(str(finding.reference)))
                self.create_table("Affected Lines",self.clean_text(str(finding.code)))
                
                # Add spacing between findings while maintaining table structure
                if i < len(findings) - 1:
                    # Add space between findings but keep table structure
                    current_y = self.get_y()
                    self.set_xy(20, current_y + 5)  # Small gap between findings
                else:
                    # Last finding - add final spacing
                    current_y = self.get_y()
                    self.set_xy(20, current_y + 3)


# Scan the code for vulnerability using semgrep cli
def scan(path):
    import os
    
    # Store current working directory
    original_cwd = os.getcwd()
    
    try:
        # Change to the project directory
        os.chdir(path)
        print(f"Changed to directory: {path}")
        
        # Run semgrep from the project directory (relative path)
        command = "semgrep scan ."
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[bold blue]{task.description}"),
        ) as progress:
            task = progress.add_task("Scanning...", total=None)  
            
            # Run the subprocess command
            result = subprocess.run(command, capture_output=True, text=True, shell=True)

            progress.update(task, completed=1) 
            progress.update(task, description="Done")  
        
        return result.stdout
        
    finally:
        # Always restore the original working directory
        os.chdir(original_cwd)
        print(f"Restored to directory: {original_cwd}")

# Check for system arguments and extract the path
def check_sysarg():
    if len(sys.argv) < 2:
        print("Usage: python generate.py [PATH] [OUTPUT_NAME]")
        print("Example: python generate.py /path/to/project/")
        print("Example: python generate.py /path/to/project/ custom-name.pdf")
        print("Note: If no output name is provided, will use: reports/<project-name>/<project-name>-yyyymmddhhmm.pdf")
        exit()
    
    if len(sys.argv) > 3:
        print("Usage: python generate.py [PATH] [OUTPUT_NAME]")
        print("Too many arguments provided.")
        exit()

    path = sys.argv[1]
    
    # Check if output filename was provided
    if len(sys.argv) == 3:
        filename = sys.argv[2]
    else:
        # Generate default filename
        filename = None
    
    return path, filename

def extract_project_name(path):
    """Extract project name from directory path"""
    # Remove trailing slash if present
    clean_path = path.rstrip('/')
    
    # Split by path separator and get the last part
    path_parts = clean_path.split('/')
    
    # Get the project name (last directory in path)
    project_name = path_parts[-1] if path_parts else "Unknown Project"
    
    return project_name

def generate_default_output_path(project_name):
    """Generate default output path: reports/<project-name>/<project-name>-yyyymmddhhmm.pdf"""
    import os
    from datetime import datetime
    
    # Create timestamp in yyyymmddhhmm format
    timestamp = datetime.now().strftime("%Y%m%d%H%M")
    
    # Create directory path
    reports_dir = f"reports/{project_name}"
    
    # Create directory if it doesn't exist
    os.makedirs(reports_dir, exist_ok=True)
    
    # Generate filename
    filename = f"{project_name}-{timestamp}.pdf"
    
    # Full path
    full_path = os.path.join(reports_dir, filename)
    
    return full_path

# Combine the description
def clean_description(messages):
    combined_messages = []
    temp = ""

    for message in messages[5:]:
        if message: 
            if temp:  
                temp += " " + message.strip()  
            else:
                temp = message.strip()  
        else:
            if temp: 
                combined_messages.append(temp)
                temp = ""  
    if temp:
        combined_messages.append(temp)
    return combined_messages

# Seperate the findings according to the severity level
def categorize_finding(lines):
    lines = lines.strip().split('\n')

    category = []  
    description = []  
    reference = [] 
    code_lines = []  

    for line in lines:
        stripped_line = line.strip()  

        if stripped_line.startswith('❯❱') or stripped_line.startswith('❱') or stripped_line.startswith('❯❯❱'):
            category.append(stripped_line)  
        elif stripped_line.lower().startswith('details:'):
            reference.append(stripped_line) 
        elif 'Details:' in stripped_line:
            continue
        elif '┆' in stripped_line:
            code_lines.append(stripped_line)  
        else:
            description.append(stripped_line)  

    return category, description, reference, code_lines

# Store the categorize findings to the class findings
def store_finding(category_deciders, descriptions, references, codes):
    high_findings = []
    medium_findings = []
    low_findings = []

    for i in range(len(category_deciders)): 
        category_decider = category_deciders[i]
        description = descriptions[i]
        reference = references[i]
        code = codes[i]

        if category_decider.startswith('❯❯❱'):
            category = "high"
            findings_list = high_findings
            
        elif category_decider.startswith('❯❱'):
            category = "medium"
            findings_list = medium_findings

        elif category_decider.startswith('❱'):
            category = "low"
            findings_list = low_findings

        else:
            continue 

        category_decider = category_decider.replace('❯❯❱', '').replace('❯❱', '').replace('❱', '').strip()
        code = code.replace('┆', '').strip()
        reference = reference.replace('Details:', '').strip()
        finding_instance = Findings(category_decider, description, reference, code)
        findings_list.append(finding_instance)

    return high_findings, medium_findings, low_findings

# Write to PDF
def generate_pdf_report(high, medium, low, filename, project_name):
    pdf = PDF()
    pdf.add_page()

    # Add main title with better styling
    pdf.set_font("Arial", style="B", size=20)
    pdf.set_text_color(30, 30, 30)
    pdf.cell(0, 15, txt="", ln=1)  # Spacing
    pdf.multi_cell(pdf.get_available_width(), 12, txt=f"Semgrep Security Analysis Report - {project_name}", align='C')
    pdf.ln(5)

    # Add executive summary section
    if pdf.check_header_space(30):  # Executive summary needs more space
        pdf.add_page()
    
    pdf.set_font("Arial", style="B", size=14)
    pdf.set_text_color(50, 50, 50)
    pdf.multi_cell(pdf.get_available_width(), 10, txt="Executive Summary")
    pdf.ln(3)
    
    # Summary statistics
    total_findings = len(high) + len(medium) + len(low)
    pdf.set_font("Arial", size=10)
    pdf.set_text_color(80, 80, 80)
    
    # Create summary table with project info
    summary_data = [
        ("Project Name", project_name),
        ("Total Findings", str(total_findings)),
        ("High Severity", str(len(high))),
        ("Medium Severity", str(len(medium))),
        ("Low Severity", str(len(low)))
    ]
    
    # Draw summary table
    pdf.set_fill_color(245, 245, 245)
    for label, value in summary_data:
        pdf.cell(pdf.get_available_width() * 0.4, 8, label, 1, 0, 'L', True)
        pdf.cell(pdf.get_available_width() * 0.6, 8, value, 1, 1, 'L', True)
    
    pdf.ln(5)
    
    # Add scan summary section
    if pdf.check_header_space(20):  # Summary needs more space
        pdf.add_page()
    pdf.set_font("Arial", style="B", size=12)
    pdf.set_text_color(60, 60, 60)
    pdf.multi_cell(pdf.get_available_width(), 10, txt=f"Scan Summary - {project_name}")
    pdf.set_font("Arial", size=10)
    pdf.set_text_color(80, 80, 80)
    pdf.multi_cell(pdf.get_available_width(), 10, findings[0])
    pdf.ln(5)
    
    # Add note about smart summaries
    pdf.set_font("Arial", style="I", size=9)
    pdf.set_text_color(120, 120, 120)
    pdf.multi_cell(pdf.get_available_width(), 8, txt="Note: Very long descriptions are automatically summarized for better readability. Full details are available in the original scan output.")
    pdf.ln(5)

    # High severity findings
    if high:
        # Check if there's enough space for the header
        if pdf.check_header_space():
            pdf.add_page()
        
        # High severity header with red accent
        pdf.set_fill_color(255, 200, 200)
        pdf.rect(20, pdf.get_y(), pdf.get_available_width(), 12, 'F')
        pdf.set_font("Arial", style="B", size=12)
        pdf.set_text_color(150, 0, 0)
        pdf.set_xy(25, pdf.get_y() + 2)
        pdf.multi_cell(pdf.get_available_width(), 10, txt="[HIGH] High Severity Findings")
        
        pdf.set_font("Arial", size=10)
        pdf.set_text_color(80, 80, 80)
        pdf.write_to_table(high,"High")
        pdf.ln(3)

    # Medium severity findings
    if medium:
        # Check if there's enough space for the header
        if pdf.check_header_space():
            pdf.add_page()
        
        # Medium severity header with orange accent
        pdf.set_fill_color(255, 240, 200)
        pdf.rect(20, pdf.get_y(), pdf.get_available_width(), 12, 'F')
        pdf.set_font("Arial", style="B", size=12)
        pdf.set_text_color(150, 100, 0)
        pdf.set_xy(25, pdf.get_y() + 2)
        pdf.multi_cell(pdf.get_available_width(), 10, txt="[MEDIUM] Medium Severity Findings")
        
        pdf.set_font("Arial", size=10)
        pdf.set_text_color(80, 80, 80)
        pdf.write_to_table(medium,"Medium")
        pdf.ln(3)

    # Low severity findings
    if low:
        # Check if there's enough space for the header
        if pdf.check_header_space():
            pdf.add_page()
        
        # Low severity header with green accent
        pdf.set_fill_color(200, 255, 200)
        pdf.rect(20, pdf.get_y(), pdf.get_available_width(), 12, 'F')
        pdf.set_font("Arial", style="B", size=12)
        pdf.set_text_color(0, 100, 0)
        pdf.set_xy(25, pdf.get_y() + 2)
        pdf.multi_cell(pdf.get_available_width(), 10, txt="[LOW] Low Severity Findings")
        
        pdf.set_font("Arial", size=10)
        pdf.set_text_color(80, 80, 80)
        pdf.write_to_table(low,"Low")

    # Add conclusion section
    if pdf.check_header_space(40):  # Conclusion needs more space
        pdf.add_page()
    
    # Always add a new page for the conclusion section
    pdf.add_page()
    
    pdf.ln(10)
    pdf.set_font("Arial", style="B", size=14)
    pdf.set_text_color(50, 50, 50)
    pdf.multi_cell(pdf.get_available_width(), 10, txt=f"Conclusion & Recommendations - {project_name}")
    pdf.ln(5)
    
    pdf.set_font("Arial", size=10)
    pdf.set_text_color(80, 80, 80)
    
    # Add recommendations based on findings
    if len(high) > 0:
        pdf.set_font("Arial", style="B", size=10)
        pdf.set_text_color(150, 0, 0)
        pdf.multi_cell(pdf.get_available_width(), 8, txt="[HIGH] High Priority Actions:")
        pdf.set_font("Arial", size=9)
        pdf.set_text_color(80, 80, 80)
        pdf.multi_cell(pdf.get_available_width(), 8, txt="- Address all high severity findings immediately")
        pdf.multi_cell(pdf.get_available_width(), 8, txt="- Review code changes before deployment")
        pdf.multi_cell(pdf.get_available_width(), 8, txt="- Implement security training for development team")
        pdf.ln(3)
    
    if len(medium) > 0:
        pdf.set_font("Arial", style="B", size=10)
        pdf.set_text_color(150, 100, 0)
        pdf.multi_cell(pdf.get_available_width(), 8, txt="[MEDIUM] Medium Priority Actions:")
        pdf.set_font("Arial", size=9)
        pdf.set_text_color(80, 80, 80)
        pdf.multi_cell(pdf.get_available_width(), 8, txt="- Plan remediation for medium severity issues")
        pdf.multi_cell(pdf.get_available_width(), 8, txt="- Review security policies and procedures")
        pdf.ln(3)
    
    pdf.set_font("Arial", style="B", size=10)
    pdf.set_text_color(50, 50, 50)
    pdf.multi_cell(pdf.get_available_width(), 8, txt="[INFO] General Recommendations:")
    pdf.set_font("Arial", size=9)
    pdf.set_text_color(80, 80, 80)
    pdf.multi_cell(pdf.get_available_width(), 8, txt="- Integrate security scanning into CI/CD pipeline")
    pdf.multi_cell(pdf.get_available_width(), 8, txt="- Regular security assessments and updates")
    pdf.multi_cell(pdf.get_available_width(), 8, txt="- Maintain security awareness and training programs")
    pdf.ln(5)

    # Save the PDF to a file
    pdf.output(filename)

if __name__ == "__main__":
    path, filename = check_sysarg()
    
    # Extract project name from path
    project_name = extract_project_name(path)
    print(f"Scanning project: {project_name}")
    
    # Generate default output path if none provided
    if filename is None:
        filename = generate_default_output_path(project_name)
        print(f"Output will be saved to: {filename}")
    
    findings = scan(path)
    category, description, reference, code = categorize_finding(findings)
    description = clean_description(description)
    high, medium, low = store_finding(category, description, reference, code)

    generate_pdf_report(high, medium, low, filename, project_name)
    
    
